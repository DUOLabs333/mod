import subprocess

import re

import tempfile

import os

import pathlib

import signal 

import time



def tempdir():

    return tempfile.gettempdir()

    

TEMPDIR=tempdir()





class DoesNotExist(Exception):

    pass



def get_root_directory(class_name,root_variable=None,default_value=None):

    root_variable=default_value(root_variable,f"{class_name.upper()}_ROOT")

    default_value=default_value(default_value,f"{os.environ['HOME']}/{class_name.title()}s")

    return os.getenv(root_variable,default_value)

    

#ROOT=get_root_directory()



def list_items_in_root(names,flags,class_name):

    All=sorted(os.listdir(utils.ROOT))

    

    if "--started" in flags:

        names+=[_ for _ in All if "Started" in eval(f"{class_name}(_).Status()") ]

        flags=flags.remove("--started")

    if "--stopped" in flags:

        names+=[_ for _ in All if "Stopped" in eval(f"{class_name}(_).Status()") ]

        flags=flags.remove("--stopped")

    if "--enabled" in flags:

        names+=[_ for _ in All if "Enabled" in eval(f"{class_name}(_).Status()") ]

        flags=flags.remove("--enabled")

    

    if "--disabled" in flags:

        names+=[_ for _ in All if "Disabled" in eval(f"{class_name}(_).Status()") ]

        flags=flags.remove("--disabled")



    if "--all" in flags:

        names+=All

        flags=flags.remove("--all")

    return (names,flags)



def flatten_list(items):

    """Yield items from any nested iterable."""

    for x in items:

        if isinstance(x, typing.Iterable) and not isinstance(x, (str, bytes)):

            for sub_x in flatten_list(x):

                yield sub_x

        else:

            yield x



def print_result_string(result):

    for element in result:

        if element is None:

            print(end='')

        else:

            print(element)



def split_string_by_char(string,char=':'):

    PATTERN = re.compile(rf'''((?:[^\{char}"']|"[^"]*"|'[^']*')+)''')

    return [_ for _ in list(PATTERN.split(string)) if _ not in ['', char]]





def shell_command(command,stdout=subprocess.PIPE,stderr=subprocess.STDOUT,arbitrary=False,block=True):

    process = subprocess.Popen(command, stdout=stdout, stderr=stderr,universal_newlines=True,shell=arbitrary)

    if block:

        return process.communicate()[0]





def get_value(variable,default):

    if not variable:

        return default

    else:

        return variable



def class_init(self,_name,_flags=None,_env=None,_function=None):

    self.name=_name

    

    self.flags=get_value(_flags,FLAGS)

    

    self.function=get_value(_function,FUNCTION)

    

    if self.function not in ["init"]:

        if not os.path.isdir(f"{utils.ROOT}/{self.name}"):

             raise DoesNotExist()

             return

        os.chdir(f"{utils.ROOT}/{self.name}")



def extract_arguments():

    arguments=sys.argv[1:]

    try:

        FUNCTION=arguments[0]

    except IndexError:

        print("No function specified!")

        exit()

    

    for i in range(len(arguments)):

        if not arguments[i].startswith("--"):

            FLAGS=arguments[:i]

            NAMES=arguments[i:]

            break

    return (FLAGS,NAMES,FUNCTION)





def add_environment_variable_to_string(string):

    return string+f"; export {env}"



def wait(delay=None):

    if not delay:

        signal.pause()

    else:

        time.sleep(int(delay))



def get_main_process(name,class_name):

    return [_[1:] for _ in utils.shell_command(["lsof","-Fp","-w",f"{utils.TEMPDIR}/{utils.class_name}_{self.name}.lock"]).splitlines()]