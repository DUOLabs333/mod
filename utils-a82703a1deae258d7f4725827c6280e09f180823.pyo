import subprocess

import re

import tempfile

import os

import pathlib

import signal 

import time



def tempdir():

    if os.uname().sysname=="Darwin":

        return "/tmp"

    else:

        return tempfile.gettempdir()

    

TEMPDIR=tempdir()





class DoesNotExist(Exception):

    pass



def get_root_directory(class_name,root_variable=None,default_value=None):

    root_variable=get_value(root_variable,f"{class_name.upper()}_ROOT")

    default_value=get_value(default_value,f"{os.environ['HOME']}/{class_name.title()}s")

    return os.path.expanduser(os.getenv(root_variable,default_value))

    

#ROOT=get_root_directory()



def list_items_in_root(names,flags,class_name):

    All=[_ for _ in sorted(os.listdir(ROOT)) if not _.startswith('.') ]

    

    if "--started" in flags:

        names+=[_ for _ in All if "Started" in eval(f"{class_name}(_).Status()") ]

        flags.remove("--started")

    if "--stopped" in flags:

        names+=[_ for _ in All if "Stopped" in eval(f"{class_name}(_).Status()") ]

        flags.remove("--stopped")

    if "--enabled" in flags:

        names+=[_ for _ in All if "Enabled" in eval(f"{class_name}(_).Status()") ]

        flags.remove("--enabled")

    

    if "--disabled" in flags:

        names+=[_ for _ in All if "Disabled" in eval(f"{class_name}(_).Status()") ]

        flags.remove("--disabled")



    if "--all" in flags:

        names+=All

        flags.remove("--all")

    return names



def flatten_list(items):

    """Yield items from any nested iterable."""

    for x in items:

        if isinstance(x, typing.Iterable) and not isinstance(x, (str, bytes)):

            for sub_x in flatten_list(x):

                yield sub_x

        else:

            yield x



def print_list(l):

    for element in l:

        if element is None:

            print(end='')

        else:

            print(element)



def split_string_by_char(string,char=':'):

    PATTERN = re.compile(rf'''((?:[^\{char}"']|"[^"]*"|'[^']*')+)''')

    return [_ for _ in list(PATTERN.split(string)) if _ not in ['', char]]





def shell_command(command,stdout=subprocess.PIPE,stderr=subprocess.STDOUT,arbitrary=False,block=True):

    process = subprocess.Popen(command, stdout=stdout, stderr=stderr,universal_newlines=True,shell=arbitrary)

    if block:

        return process.communicate()[0]





def get_value(variable,default):

    if not variable:

        return default

    else:

        return variable



def class_init(class_self,_name,_flags=None,_env=None,_function=None):

    class_self.name=_name

    

    class_self.flags=get_value(_flags,FLAGS)

    

    class_self.function=get_value(_function,FUNCTION)

    

    if class_self.function not in ["init"]:

        if not os.path.isdir(f"{ROOT}/{class_self.name}"):

             raise DoesNotExist()

             return

        os.chdir(f"{ROOT}/{class_self.name}")



def extract_arguments():

    arguments=sys.argv[1:]

    try:

        FUNCTION=arguments[0]

    except IndexError:

        print("No function specified!")

        exit()

    arguments=arguments[1:]

    

    NAMES=[]

    FLAGS=arguments

    for i in range(len(arguments)):

        if not arguments[i].startswith("--"):

            FLAGS=arguments[:i]

            NAMES=arguments[i:]

            break

    

    return (NAMES,FLAGS,FUNCTION)



FLAGS, NAMES, FUNCTION = extract_arguments()



def add_environment_variable_to_string(string,env_var):

    return string+f"; export {env}"



def wait(delay=None):

    if not delay:

        signal.pause()

    else:

        time.sleep(int(delay))



def get_main_process(name,class_name):

    return list(map(int,[_[1:] for _ in shell_command(["lsof","-Fp","-w",f"{TEMPDIR}/{class_name}_{self.name}.lock"]).splitlines()]))





def execute_class_method(class_instance,function):

    if not callable(getattr(class_instance, function.title(),None)):

            print(f"Command {function} doesn't exist!")

            exit()

    else:

        return list(flatten([getattr(class_instance,function.title())()]))



def export_methods_globally(class_instance_string):

    Class=eval(f"{class_instance_string}.__class__")

    for func in [func for func in dir(Class) if callable(getattr(Class, func)) and not func.startswith('__')]:

        exec(f"{func} = {class_instance_string}.{func}")
